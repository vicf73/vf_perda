# -*- coding: utf-8 -*-
import streamlit as st
import pandas as pd
import datetime
import io
import chardet
import bcrypt
import os
from io import BytesIO
from zipfile import ZipFile

# Para PostgreSQL e ORM (SQLAlchemy)
try:
    from sqlalchemy import create_engine, text, inspect
    from sqlalchemy.exc import SQLAlchemyError
    SQLALCHEMY_AVAILABLE = True
except ImportError:
    st.error("‚ùå SQLAlchemy n√£o est√° instalado. Instale com: pip install sqlalchemy psycopg2-binary")
    st.stop()

# --- Configura√ß√£o das Credenciais do Banco de Dados ---

try:
    POSTGRES_CONFIG = {
        'host': st.secrets["postgres"]["host"],
        'port': st.secrets["postgres"]["port"],
        'database': st.secrets["postgres"]["database"],
        'user': st.secrets["postgres"]["user"],
        'password': st.secrets["postgres"]["password"]
    }
    POSTGRES_URL = (
        f"postgresql+psycopg2://{POSTGRES_CONFIG['user']}:{POSTGRES_CONFIG['password']}@"
        f"{POSTGRES_CONFIG['host']}:{POSTGRES_CONFIG['port']}/{POSTGRES_CONFIG['database']}"
    )
except KeyError as e:
    st.error(f"‚ùå Credencial n√£o encontrada nos secrets do Streamlit: {e}")
    st.info("üí° Verifique se todas as credenciais est√£o configuradas no painel do Streamlit Cloud")
    st.stop()
except Exception as e:
    st.error(f"‚ùå Erro ao carregar configura√ß√µes do banco: {e}")
    st.stop()

# --- DatabaseManager para PostgreSQL ---
class PostgresDatabaseManager:
    """Gerencia a conex√£o e opera√ß√µes com o banco de dados PostgreSQL, 
    incluindo autentica√ß√£o segura (bcrypt) e opera√ß√µes de dados otimizadas.
    """
    def __init__(self, database_url):
        self.database_url = database_url
        self.engine = None
        
        try:
            self.engine = create_engine(
                self.database_url,
                pool_pre_ping=True,
                connect_args={"connect_timeout": 10}
            )
            self.init_db()
        except Exception as e:
            st.error(f"‚ùå Erro ao conectar com PostgreSQL: {e}")
            raise

    def _get_conn(self):
        """Retorna uma conex√£o ativa com o banco."""
        return self.engine.connect()

    # --- Inicializa√ß√£o e Estrutura do BD ---
    def init_db(self):
        """Cria as tabelas 'bd' e 'usuarios' e insere usu√°rios padr√£o se necess√°rio."""
        try:
            with self.engine.connect() as conn:
                # Tabela BD
                conn.execute(text('''
                    CREATE TABLE IF NOT EXISTS bd (
                        cil TEXT, prod TEXT, contador TEXT, leitura TEXT, mat_contador TEXT,
                        med_fat TEXT, qtd DOUBLE PRECISION, valor DOUBLE PRECISION, situacao TEXT, acordo TEXT,
                        nib TEXT, seq TEXT, localidade TEXT, pt TEXT, desv TEXT,
                        mat_leitura TEXT, desc_uni TEXT, est_contr TEXT, anomalia TEXT, id TEXT,
                        produto TEXT, nome TEXT, criterio TEXT, desc_tp_cli TEXT, tip TEXT,
                        tarifa TEXT, modelo TEXT, lat DOUBLE PRECISION, long DOUBLE PRECISION, fraud TEXT,
                        estado TEXT
                    )
                '''))
                
                # Tabela de usu√°rios
                conn.execute(text('''
                    CREATE TABLE IF NOT EXISTS usuarios (
                        id SERIAL PRIMARY KEY,
                        username TEXT UNIQUE NOT NULL,
                        password_hash TEXT NOT NULL,
                        nome TEXT NOT NULL,
                        role TEXT NOT NULL,
                        data_criacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                '''))
                
                # Inserir usu√°rios padr√£o se a tabela estiver vazia
                result = conn.execute(text("SELECT COUNT(*) FROM usuarios"))
                count = result.scalar()
                if count == 0:
                    usuarios_padrao = [
                        ('Admin', self.hash_password('admin123'), 'Administrador Principal', 'Administrador'),
                        ('AssAdm', self.hash_password('adm123'), 'Assistente Administrativo', 'Assistente Administrativo')
                    ]
                    for user in usuarios_padrao:
                        try:
                            conn.execute(
                                text("INSERT INTO usuarios (username, password_hash, nome, role) VALUES (:username, :password_hash, :nome, :role)"),
                                {"username": user[0], "password_hash": user[1], "nome": user[2], "role": user[3]}
                            )
                        except SQLAlchemyError:
                            continue  # Usu√°rio j√° existe
                    conn.commit()
        except Exception as e:
            st.error(f"‚ùå Erro ao inicializar banco de dados: {e}")

    # --- Fun√ß√µes de Hashing e Autentica√ß√£o (bcrypt) ---
    @staticmethod
    def hash_password(password):
        """Gera um hash seguro da senha usando bcrypt."""
        # O salt √© gerado automaticamente pelo bcrypt.gensalt()
        hashed = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
        return hashed.decode('utf-8')

    def autenticar_usuario(self, username, password):
        """Verifica as credenciais do usu√°rio usando bcrypt."""
        try:
            with self.engine.connect() as conn:
                result = conn.execute(
                    text("SELECT id, username, password_hash, nome, role FROM usuarios WHERE username = :username"),
                    {"username": username}
                )
                usuario = result.fetchone()
            
            if usuario:
                try:
                    # user[2] √© o password_hash
                    if bcrypt.checkpw(password.encode('utf-8'), usuario[2].encode('utf-8')):
                        return {'id': usuario[0], 'username': usuario[1], 'nome': usuario[3], 'role': usuario[4]}
                except ValueError:
                    # Hash inv√°lido ou corrompido
                    return None 
            return None
        except Exception as e:
            st.error(f"‚ùå Erro na autentica√ß√£o: {e}")
            return None

    # --- Fun√ß√µes de Gerenciamento de Usu√°rios ---
    def obter_usuarios(self):
        """Retorna a lista de todos os usu√°rios."""
        try:
            with self.engine.connect() as conn:
                df = pd.read_sql_query(text("SELECT id, username, nome, role, data_criacao FROM usuarios ORDER BY username"), conn)
            return df.to_records(index=False).tolist()
        except Exception as e:
            st.error(f"‚ùå Erro ao obter usu√°rios: {e}")
            return []

    def criar_usuario(self, username, password, nome, role):
        """Cria um novo usu√°rio."""
        try:
            password_hash = self.hash_password(password)
            with self.engine.connect() as conn:
                conn.execute(
                    text("INSERT INTO usuarios (username, password_hash, nome, role) VALUES (:username, :password_hash, :nome, :role)"),
                    {"username": username, "password_hash": password_hash, "nome": nome, "role": role}
                )
                conn.commit()
            return True, "Usu√°rio criado com sucesso!"
        except SQLAlchemyError as e:
            if 'duplicate key value violates unique constraint' in str(e):
                return False, f"O nome de usu√°rio '{username}' j√° existe."
            return False, f"Erro ao criar usu√°rio: {e}"

    def editar_usuario(self, user_id, nome, role):
        """Edita nome e fun√ß√£o de um usu√°rio existente."""
        try:
            with self.engine.connect() as conn:
                result = conn.execute(
                    text("UPDATE usuarios SET nome = :nome, role = :role WHERE id = :id"),
                    {"nome": nome, "role": role, "id": user_id}
                )
                conn.commit()
            return result.rowcount > 0, "Usu√°rio editado com sucesso!"
        except SQLAlchemyError as e:
            return False, f"Erro ao editar usu√°rio: {e}"

    def excluir_usuario(self, user_id):
        """Exclui um usu√°rio pelo ID."""
        try:
            with self.engine.connect() as conn:
                result = conn.execute(
                    text("DELETE FROM usuarios WHERE id = :id"),
                    {"id": user_id}
                )
                conn.commit()
            return result.rowcount > 0, "Usu√°rio exclu√≠do com sucesso!"
        except SQLAlchemyError as e:
            return False, f"Erro ao excluir usu√°rio: {e}"

    def alterar_senha(self, user_id, new_password):
        """Altera a senha de um usu√°rio existente."""
        try:
            password_hash = self.hash_password(new_password)
            with self.engine.connect() as conn:
                result = conn.execute(
                    text("UPDATE usuarios SET password_hash = :hash WHERE id = :id"),
                    {"hash": password_hash, "id": user_id}
                )
                conn.commit()
            return result.rowcount > 0, "Senha alterada com sucesso!"
        except SQLAlchemyError as e:
            return False, f"Erro ao alterar senha: {e}"

    # --- Fun√ß√µes Auxiliares de CSV ---
    def _detectar_encoding(self, arquivo_csv):
        """Detecta o encoding do arquivo."""
        raw_data = arquivo_csv.getvalue()
        result = chardet.detect(raw_data)
        return result['encoding']

    def _detectar_separador(self, arquivo_csv, encoding):
        """Detecta o separador mais prov√°vel (',' ou ';')."""
        arquivo_csv.seek(0)
        try:
            # Tenta ler 50 linhas
            amostra = arquivo_csv.read(1024 * 50).decode(encoding, errors='ignore')
            
            # Conta ocorr√™ncias de ',' e ';'
            virgula_count = amostra.count(',')
            ponto_virgula_count = amostra.count(';')
            
            # Assume o que tiver maior contagem
            if ponto_virgula_count > virgula_count * 2: # Prefer√™ncia por ';' se for significativamente maior
                return ';'
            else:
                return ','
        finally:
            arquivo_csv.seek(0)
    
    # --- Fun√ß√µes de Importa√ß√£o e Dados (Otimizadas) ---
    def importar_csv(self, arquivo_csv, tabela='BD', colunas_esperadas=31):
        """Importa dados do CSV para a tabela BD do PostgreSQL, otimizado para grandes volumes."""
        try:
            # 1. Detec√ß√£o e Leitura
            encoding = self._detectar_encoding(arquivo_csv)
            separador = self._detectar_separador(arquivo_csv, encoding)

            if tabela == 'BD':
                # low_memory=False: melhora a performance e previne problemas de dtype em grandes arquivos
                df_novo = pd.read_csv(arquivo_csv, sep=separador, encoding=encoding, 
                                      on_bad_lines='skip', header=None, low_memory=False) 
                
                if len(df_novo.columns) < colunas_esperadas:
                    st.error(f"‚ùå O arquivo BD deve ter pelo menos {colunas_esperadas} colunas.")
                    return False
                
                # Mapeamento de colunas
                column_mapping = {
                    0: 'cil', 1: 'prod', 2: 'contador', 3: 'leitura', 4: 'mat_contador',
                    5: 'med_fat', 6: 'qtd', 7: 'valor', 8: 'situacao', 9: 'acordo',
                    10: 'nib', 11: 'seq', 12: 'localidade', 13: 'pt', 14: 'desv',
                    15: 'mat_leitura', 16: 'desc_uni', 17: 'est_contr', 18: 'anomalia', 19: 'id',
                    20: 'produto', 21: 'nome', 22: 'criterio', 23: 'desc_tp_cli', 24: 'tip',
                    25: 'tarifa', 26: 'modelo', 27: 'lat', 28: 'long', 29: 'fraud',
                    30: 'estado'
                }
                
                df_novo.rename(columns=column_mapping, inplace=True)
                
                # 2. Tratamento e Limpeza (Crucial para Filtros)
                for col in ['criterio', 'pt', 'localidade', 'nib', 'cil', 'estado']:
                    if col in df_novo.columns:
                        df_novo[col] = df_novo[col].fillna('').astype(str).str.strip()

                df_novo['criterio'] = df_novo['criterio'].str.upper()
                df_novo['pt'] = df_novo['pt'].str.upper()
                df_novo['localidade'] = df_novo['localidade'].str.upper()
                df_novo['estado'] = df_novo['estado'].str.lower()
                
                # Tratamento de Num√©ricos
                df_novo['qtd'] = pd.to_numeric(df_novo['qtd'], errors='coerce').fillna(0)
                df_novo['valor'] = pd.to_numeric(df_novo['valor'], errors='coerce').fillna(0)
                df_novo['lat'] = pd.to_numeric(df_novo['lat'], errors='coerce')
                df_novo['long'] = pd.to_numeric(df_novo['long'], errors='coerce')
                
                # 3. Opera√ß√µes no BD
                with self.engine.connect() as conn:
                    # Criar tabela tempor√°ria
                    df_novo.to_sql('bd_temp_import', conn, if_exists='replace', index=False)
                    
                    # Preservar estado 'prog' existente (JOIN para efici√™ncia)
                    update_query = text("""
                        UPDATE bd_temp_import as new 
                        SET estado = 'prog' 
                        FROM bd as old
                        WHERE new.cil = old.cil AND old.estado = 'prog'
                    """)
                    result = conn.execute(update_query)
                    st.info(f"O estado 'prog' foi preservado para {result.rowcount} registro(s) durante a importa√ß√£o.")
                    
                    # Substituir a tabela BD
                    conn.execute(text("DROP TABLE IF EXISTS bd CASCADE"))
                    conn.execute(text("ALTER TABLE bd_temp_import RENAME TO bd"))
                    conn.commit()

                self.ordenar_tabela_bd()
                return True
            
        except Exception as e:
            st.error(f"‚ùå Erro ao importar arquivo para PostgreSQL: {str(e)}")
            return False

    def ordenar_tabela_bd(self):
        """Placeholder: A ordena√ß√£o f√≠sica √© desabilitada. A ordena√ß√£o ser√° feita nas QUERIES."""
        st.info("‚ÑπÔ∏è Ordena√ß√£o da tabela BD f√≠sica desabilitada para otimiza√ß√£o de performance.")
        return True

    def obter_valores_unicos(self, coluna, tabela='bd'):
        """Obt√©m valores √∫nicos de uma coluna, com limpeza de string no SQL."""
        try:
            with self.engine.connect() as conn:
                coluna_sql = coluna.lower()
                    
                # Limpeza (UPPER/TRIM) no SQL para garantir a consist√™ncia
                query = text(f"""
                    SELECT DISTINCT UPPER(TRIM({coluna_sql})) as valor_unico
                    FROM {tabela} 
                    WHERE {coluna_sql} IS NOT NULL 
                    AND TRIM({coluna_sql}) != '' 
                    AND TRIM(UPPER({coluna_sql})) NOT IN ('NONE', 'NULL')
                    ORDER BY valor_unico
                """)
                
                df = pd.read_sql_query(query, conn)
                return df['valor_unico'].tolist()
        except Exception as e:
            st.error(f"‚ùå Erro ao obter valores √∫nicos para {coluna}: {e}")
            return []

    def gerar_folhas_trabalho(self, tipo_folha, valor_selecionado, quantidade_folhas, quantidade_nibs, cils_validos=None):
        """Gera folhas de trabalho, movendo a filtragem e ordena√ß√£o complexas para o SQL."""
        try:
            with self.engine.connect() as conn:
                
                cils_restantes_nao_encontrados = []
                
                # 1. Constru√ß√£o da Query de Sele√ß√£o (Performance)
                select_clause = "SELECT * FROM bd"
                where_conditions = ["UPPER(TRIM(criterio)) = 'SUSP'", "LOWER(TRIM(estado)) != 'prog'"]
                query_params = {}
                
                if tipo_folha == "AVULSO" and cils_validos:
                    # Uso de ANY para passar a lista de CILs
                    where_conditions.append("cil = ANY(:cils)")
                    query_params['cils'] = cils_validos
                elif valor_selecionado:
                    # Limpeza do valor e filtro no SQL (UPPER/TRIM)
                    valor_selecionado_limpo = valor_selecionado.strip().upper()
                    coluna_filtro = 'pt' if tipo_folha == "PT" else 'localidade'
                    where_conditions.append(f"UPPER(TRIM({coluna_filtro})) = :valor_filtro")
                    query_params['valor_filtro'] = valor_selecionado_limpo
                
                # 2. Ordena√ß√£o dentro da Query para garantir a sequ√™ncia correta
                order_by_clause = """
                    ORDER BY 
                        CASE WHEN seq IS NULL OR TRIM(seq) = '' THEN 1 ELSE 0 END, seq,
                        CASE WHEN nib IS NULL OR TRIM(nib) = '' THEN 1 ELSE 0 END, nib
                """
                full_query = f"{select_clause} WHERE {' AND '.join(where_conditions)} {order_by_clause}"
                
                df = pd.read_sql_query(text(full_query), conn, params=query_params)

                if tipo_folha == "AVULSO" and cils_validos:
                    cils_encontrados = set(df['cil'].unique()) if not df.empty else set()
                    cils_restantes_nao_encontrados = list(set(cils_validos) - cils_encontrados)

                if df.empty:
                    return None, cils_restantes_nao_encontrados
                
                # 3. Gera√ß√£o das Folhas (em mem√≥ria, com base nos NIBs)
                df['nib'] = df['nib'].fillna('').astype(str).str.strip()
                nibs_unicos = df['nib'].unique()
                total_nibs = len(nibs_unicos)
                
                if total_nibs == 0:
                    return None, cils_restantes_nao_encontrados
                
                folhas_possiveis = (total_nibs + quantidade_nibs - 1) // quantidade_nibs
                quantidade_folhas = min(quantidade_folhas, folhas_possiveis)
                
                folhas = []
                total_registros_atualizados = 0
                
                for i in range(quantidade_folhas):
                    nibs_na_folha = nibs_unicos[i * quantidade_nibs: (i + 1) * quantidade_nibs].tolist()
                    folha_df = df[df['nib'].isin(nibs_na_folha)].copy()
                    folha_df['FOLHA'] = i + 1
                    folhas.append(folha_df)
                    
                    # 4. Atualiza√ß√£o de Estado (em bloco via SQL)
                    update_where_conditions = ["LOWER(TRIM(estado)) != 'prog'"]
                    update_params = {'nibs': nibs_na_folha}
                    
                    if tipo_folha == "PT" or tipo_folha == "LOCALIDADE":
                        coluna_filtro = 'pt' if tipo_folha == "PT" else 'localidade'
                        update_where_conditions.append(f"UPPER(TRIM({coluna_filtro})) = :valor_update")
                        update_params['valor_update'] = valor_selecionado.strip().upper()
                    
                    # Uso de ANY para passar a lista de NIBs com seguran√ßa na atualiza√ß√£o
                    update_query = text(f"""
                        UPDATE bd SET estado = 'prog' 
                        WHERE nib = ANY(:nibs) AND {' AND '.join(update_where_conditions)}
                    """)
                    
                    result = conn.execute(update_query, update_params)
                    total_registros_atualizados += result.rowcount
            
                conn.commit()
                st.success(f"‚úÖ Estado atualizado para 'prog' em {total_registros_atualizados} registros.")
                
                if folhas:
                    resultado_df = pd.concat(folhas, ignore_index=True)
                    return resultado_df, cils_restantes_nao_encontrados
                else:
                    return None, cils_restantes_nao_encontrados
            
        except Exception as e:
            st.error(f"‚ùå Erro ao gerar folhas no Postgres: {str(e)}")
            return None, []

    def resetar_estado(self, tipo, valor):
        """Reseta o estado 'prog' para o tipo e valor selecionados, com limpeza no SQL."""
        try:
            with self.engine.connect() as conn:
                valor_sql = valor.strip().upper()
                
                if tipo == 'PT':
                    # Aplica UPPER/TRIM no SQL para bater com o dado limpo
                    query = text("UPDATE bd SET estado = '' WHERE LOWER(TRIM(estado)) = 'prog' AND UPPER(TRIM(pt)) = :valor")
                    params = {"valor": valor_sql}
                elif tipo == 'LOCALIDADE':
                    # Aplica UPPER/TRIM no SQL para bater com o dado limpo
                    query = text("UPDATE bd SET estado = '' WHERE LOWER(TRIM(estado)) = 'prog' AND UPPER(TRIM(localidade)) = :valor")
                    params = {"valor": valor_sql}
                elif tipo == 'AVULSO':
                    query = text("UPDATE bd SET estado = '' WHERE LOWER(TRIM(estado)) = 'prog'")
                    params = {}
                else:
                    return False, "Tipo de reset inv√°lido."
                    
                result = conn.execute(query, params)
                conn.commit()
                registros_afetados = result.rowcount
                return True, registros_afetados
                
        except Exception as e:
            st.error(f"‚ùå Erro ao resetar o estado no Postgres: {str(e)}")
            return False, 0

# --- Fun√ß√µes de Interface Streamlit ---

def generate_csv_zip(df_completo, num_nibs_por_folha):
    """Gera um arquivo ZIP contendo m√∫ltiplas folhas CSV com apenas as 10 primeiras colunas."""
    try:
        if df_completo.empty or 'FOLHA' not in df_completo.columns:
            st.error("‚ùå Nenhum dado v√°lido para exportar.")
            return None
            
        # Extrai o n√∫mero m√°ximo de folhas geradas
        max_folha = df_completo['FOLHA'].max()
        
        # Define as 10 primeiras colunas que ser√£o exportadas (A a J)
        colunas_exportar = [
            'cil', 'prod', 'contador', 'leitura', 'mat_contador',
            'med_fat', 'qtd', 'valor', 'situacao', 'acordo'
        ]
        
        # Verifica se todas as colunas existem no DataFrame
        colunas_disponiveis = [col for col in colunas_exportar if col in df_completo.columns]
        
        if len(colunas_disponiveis) < len(colunas_exportar):
            st.warning(f"‚ö†Ô∏è Algumas colunas n√£o encontradas. Exportando {len(colunas_disponiveis)} colunas.")
        
        # Cria um buffer de mem√≥ria para o ZIP
        zip_buffer = BytesIO()
        
        with ZipFile(zip_buffer, 'w') as zip_file:
            for i in range(1, max_folha + 1):
                folha_df = df_completo[df_completo['FOLHA'] == i]
                
                if folha_df.empty:
                    continue
                    
                # Seleciona apenas as colunas desejadas
                folha_df_export = folha_df[colunas_disponiveis].copy()
                
                # Cria um buffer de mem√≥ria para o arquivo CSV
                csv_buffer = BytesIO()
                
                # Exporta para CSV
                folha_df_export.to_csv(csv_buffer, index=False, encoding='utf-8-sig')
                csv_buffer.seek(0)
                
                # Adiciona o arquivo CSV ao ZIP
                zip_file.writestr(f'Folha_Trabalho_{i}.csv', csv_buffer.getvalue())

        zip_buffer.seek(0)
        return zip_buffer.read()
    except Exception as e:
        st.error(f"‚ùå Erro ao gerar arquivo ZIP: {e}")
        return None

def extrair_cils_do_xlsx(arquivo_xlsx):
    """Extrai a lista de CILs de um arquivo XLSX com diferentes formatos."""
    try:
        if arquivo_xlsx is None:
            return []
            
        # L√™ o arquivo XLSX
        df = pd.read_excel(arquivo_xlsx)
        
        if df.empty:
            st.warning("‚ö†Ô∏è O arquivo Excel est√° vazio.")
            return []
        
        st.info(f"üìÅ Arquivo processado: {len(df)} linhas, {len(df.columns)} colunas")
        
        # Tenta encontrar a coluna com CILs
        coluna_cil = None
        
        # Procura por colunas que podem conter CILs
        possiveis_colunas = ['cil', 'CIL', 'Cil', 'CODIGO', 'c√≥digo', 'C√≥digo', 'numero', 'n√∫mero']
        
        for col in df.columns:
            col_clean = str(col).strip().lower()
            if any(possivel in col_clean for possivel in ['cil', 'c√≥digo', 'codigo', 'numero', 'n√∫mero']):
                coluna_cil = col
                break
        
        # Se n√£o encontrou coluna espec√≠fica, usa a primeira coluna
        if coluna_cil is None:
            coluna_cil = df.columns[0]
            st.warning(f"‚ÑπÔ∏è Coluna 'cil' n√£o encontrada. Usando a primeira coluna: '{coluna_cil}'")
        else:
            st.success(f"‚úÖ Coluna identificada: '{coluna_cil}'")
        
        # Extrai os CILs
        cils = df[coluna_cil].dropna().astype(str).str.strip()
        
        # Remove poss√≠veis valores de cabe√ßalho
        valores_indesejados = ['cil', 'cils', 'c√≥digo', 'codigo', 'nome', 'numero', 'n√∫mero', 'nan', '']
        cils = cils[~cils.str.lower().isin(valores_indesejados)]
        
        # Converte para lista e remove duplicatas
        cils_unicos = list(set(cils.tolist()))
        
        # Filtra apenas valores n√£o vazios e v√°lidos
        cils_validos = [cil for cil in cils_unicos if cil and cil != 'nan' and cil.strip()]
        
        st.success(f"üìä {len(cils_validos)} CIL(s) √∫nico(s) extra√≠do(s)")
        
        return cils_validos
        
    except Exception as e:
        st.error(f"‚ùå Erro ao ler arquivo XLSX: {str(e)}")
        return []

def reset_state_form(db_manager, reset_key):
    """Formul√°rio para resetar o estado 'prog'."""
    st.markdown("### üîÑ Resetar Estado de Registros")
    
    tipos_reset = ["PT", "LOCALIDADE", "AVULSO"]
    tipo_reset = st.selectbox("Selecione o Tipo de Reset:", tipos_reset, key=f"reset_type_{reset_key}")
    
    valor_reset = ""
    if tipo_reset in ["PT", "LOCALIDADE"]:
        coluna = tipo_reset
        valores_unicos = db_manager.obter_valores_unicos(coluna)
        if valores_unicos:
            valores_unicos.insert(0, "Selecione...")
            valor_reset = st.selectbox(f"Selecione o valor de **{coluna}** a resetar:", valores_unicos, key=f"reset_value_{reset_key}")
        else:
            st.warning("Nenhum valor encontrado para esta coluna.")
            valor_reset = None
        
    elif tipo_reset == "AVULSO":
        st.warning("‚ö†Ô∏è O reset 'Avulso' apagar√° o estado 'prog' de **TODOS** os registros no banco, independentemente de PT/Localidade.")
        
    if st.button(f"üî¥ Confirmar Reset - {tipo_reset}", key=f"reset_button_{reset_key}"):
        if tipo_reset in ["PT", "LOCALIDADE"] and (valor_reset in ["Selecione...", ""] or valor_reset is None):
            st.error("Por favor, selecione um valor v√°lido para PT ou Localidade.")
        else:
            with st.spinner("Resetando estado..."):
                sucesso, resultado = db_manager.resetar_estado(tipo_reset, valor_reset)
            if sucesso:
                st.success(f"‚úÖ Reset conclu√≠do. {resultado} registro(s) tiveram o estado 'prog' removido.")
            else:
                st.error(f"‚ùå Falha ao resetar: {resultado}")

def gerenciar_usuarios(db_manager):
    """Gerencia usu√°rios (apenas para admin)."""
    st.markdown("### üë• Gerenciamento de Usu√°rios")
    
    # --- Criar Novo Usu√°rio ---
    with st.expander("‚ûï Criar Novo Usu√°rio"):
        with st.form("new_user_form"):
            new_username = st.text_input("Nome de Usu√°rio (login)")
            new_name = st.text_input("Nome Completo")
            new_password = st.text_input("Senha", type="password")
            new_role = st.selectbox("Fun√ß√£o:", ['Administrador', 'Assistente Administrativo', 'T√©cnico'])
            
            if st.form_submit_button("üë§ Criar Usu√°rio"):
                if new_username and new_password and new_name:
                    sucesso, mensagem = db_manager.criar_usuario(new_username, new_password, new_name, new_role)
                    if sucesso:
                        st.success(mensagem)
                        st.rerun()
                    else:
                        st.error(mensagem)
                else:
                    st.error("Preencha todos os campos obrigat√≥rios.")
                        
    st.markdown("---")
    
    # --- Visualizar/Editar/Excluir Usu√°rios ---
    st.subheader("üìã Lista de Usu√°rios Existentes")
    usuarios = db_manager.obter_usuarios()
    
    if usuarios:
        for u in usuarios:
            col_u1, col_u2, col_u3, col_u4 = st.columns([2, 2, 2, 3])
            
            user_id = u[0]
            
            with col_u1:
                st.text_input("Login", u[1], key=f"user_login_{user_id}", disabled=True)
            with col_u2:
                nome_edit = st.text_input("Nome", u[2], key=f"user_name_{user_id}")
            with col_u3:
                roles = ['Administrador', 'Assistente Administrativo', 'T√©cnico']
                try:
                    current_index = roles.index(u[3])
                except ValueError:
                    current_index = 0
                role_edit = st.selectbox("Fun√ß√£o", roles, index=current_index, key=f"user_role_{user_id}")

            with col_u4:
                action = st.radio(
                    "A√ß√£o", 
                    ['Nenhuma', 'Editar', 'Alterar Senha', 'Excluir'], 
                    key=f"user_action_{user_id}", 
                    horizontal=True
                )
                
                # A√ß√µes
                if action == 'Editar' and st.button("üíæ Salvar", key=f"save_edit_{user_id}"):
                    sucesso, mensagem = db_manager.editar_usuario(user_id, nome_edit, role_edit)
                    if sucesso: 
                        st.success(mensagem)
                        st.rerun()
                    else: 
                        st.error(mensagem)
                    
                elif action == 'Alterar Senha':
                    new_pass_edit = st.text_input("Nova Senha", type="password", key=f"new_pass_{user_id}")
                    if st.button("üîë Alterar Senha", key=f"save_pass_{user_id}"):
                        if new_pass_edit:
                            sucesso, mensagem = db_manager.alterar_senha(user_id, new_pass_edit)
                            if sucesso: 
                                st.success(mensagem)
                                st.rerun()
                            else: 
                                st.error(mensagem)
                        else:
                            st.warning("A senha n√£o pode ser vazia.")
                            
                elif action == 'Excluir' and st.button("üóëÔ∏è Excluir", key=f"confirm_delete_{user_id}"):
                    if user_id == 1 and u[1] == 'Admin':
                        st.error("N√£o √© permitido excluir o usu√°rio Administrador Principal padr√£o.")
                    else:
                        sucesso, mensagem = db_manager.excluir_usuario(user_id)
                        if sucesso: 
                            st.success(mensagem)
                            st.rerun()
                        else: 
                            st.error(mensagem)

    else:
        st.info("Nenhum usu√°rio encontrado no banco de dados.")

def gerar_folhas_trabalho(db_manager, user):
    """Fun√ß√£o compartilhada para gera√ß√£o de folhas."""
    st.markdown("### üìù Gerar Folhas de Trabalho")

    tipos_folha = ["PT", "LOCALIDADE", "AVULSO"]
    tipo_selecionado = st.radio("Tipo de Gera√ß√£o:", tipos_folha, horizontal=True)
    
    valor_selecionado = None
    arquivo_xlsx = None
    
    if tipo_selecionado in ["PT", "LOCALIDADE"]:
        coluna = tipo_selecionado
        valores_unicos = db_manager.obter_valores_unicos(coluna)
        if valores_unicos:
            valores_unicos.insert(0, "Selecione...")
            valor_selecionado = st.selectbox(f"Selecione o valor de **{coluna}**:", valores_unicos)
            if valor_selecionado == "Selecione...":
                valor_selecionado = None
        else:
            st.warning("Nenhum valor encontrado para esta coluna.")
                
    elif tipo_selecionado == "AVULSO":
        st.markdown("""
        #### üìã Importar Lista de CILs via Arquivo XLSX
        
        **Instru√ß√µes:**
        1. Prepare um arquivo Excel (.xlsx) com uma coluna contendo os CILs
        2. A coluna preferencialmente deve se chamar **'cil'**
        3. Fa√ßa o upload do arquivo abaixo
        4. O sistema ir√° automaticamente detectar e extrair os CILs
        """)
        
        # Upload de arquivo XLSX (√∫nica op√ß√£o agora)
        arquivo_xlsx = st.file_uploader(
            "Fa√ßa upload do arquivo XLSX com a lista de CILs", 
            type=["xlsx"], 
            key="upload_cils_xlsx",
            help="O arquivo deve conter uma coluna com os CILs (preferencialmente chamada 'cil')"
        )
        
        if arquivo_xlsx is not None:
            # Mostrar preview do arquivo
            try:
                df_preview = pd.read_excel(arquivo_xlsx)
                st.success(f"‚úÖ Arquivo carregado com sucesso! {len(df_preview)} linhas encontradas.")
                
                # Mostrar preview das primeiras linhas
                with st.expander("üëÄ Visualizar primeiras linhas do arquivo"):
                    st.dataframe(df_preview.head(10))
                    
                # Extrair CILs do arquivo
                cils_do_arquivo = extrair_cils_do_xlsx(arquivo_xlsx)
                if cils_do_arquivo:
                    st.info(f"üìä {len(cils_do_arquivo)} CIL(s) √∫nico(s) identificado(s)")
                    # Mostrar alguns CILs como exemplo
                    st.write("**Primeiros CILs encontrados:**", ", ".join(cils_do_arquivo[:5]) + ("..." if len(cils_do_arquivo) > 5 else ""))
            except Exception as e:
                st.error(f"‚ùå Erro ao processar arquivo: {e}")
    
    # Template para download
    if tipo_selecionado == "AVULSO":
        st.markdown("---")
        with st.expander("üìã Baixar Template de Exemplo"):
            st.markdown("""
            **Template recomendado:**
            - Arquivo XLSX com uma coluna chamada **'cil'**
            - Uma lista de CILs na coluna (um por linha)
            - Cabe√ßalho na primeira linha
            """)
            
            # Criar template exemplo
            template_data = {
                'cil': [
                    '60237270', '60041040', '60110028', '60035026', '60165161',
                    '60228646', '60154604', '60228647', '60011435'
                ]
            }
            df_template = pd.DataFrame(template_data)
            
            # Criar arquivo template para download
            template_buffer = BytesIO()
            with pd.ExcelWriter(template_buffer, engine='xlsxwriter') as writer:
                df_template.to_excel(writer, sheet_name='CILs', index=False)
            template_buffer.seek(0)
            
            st.download_button(
                label="üì• Baixar Template de Exemplo",
                data=template_buffer.getvalue(),
                file_name="template_cils.xlsx",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            )
            
    # Par√¢metros de Gera√ß√£o
    col1, col2 = st.columns(2)
    with col1:
        num_nibs_por_folha = st.number_input("NIBs por Folha:", min_value=1, value=50)
    with col2:
        max_folhas = st.number_input("M√°ximo de Folhas a Gerar:", min_value=1, value=10)

    if st.button("üöÄ Gerar e Baixar Folhas de Trabalho"):
        if tipo_selecionado != "AVULSO" and not valor_selecionado:
            st.error("Por favor, selecione um valor v√°lido de PT ou Localidade.")
        elif tipo_selecionado == "AVULSO" and not arquivo_xlsx:
            st.error("Por favor, fa√ßa upload de um arquivo XLSX com a lista de CILs.")
        else:
            cils_validos = None
            if tipo_selecionado == "AVULSO":
                # Apenas via arquivo XLSX
                cils_validos = extrair_cils_do_xlsx(arquivo_xlsx)
                if not cils_validos:
                    st.error("Nenhum CIL v√°lido encontrado no arquivo XLSX. Verifique o formato do arquivo.")
                    return

            with st.spinner("Gerando folhas de trabalho e atualizando estado no banco..."):
                df_folhas, cils_nao_encontrados = db_manager.gerar_folhas_trabalho(
                    tipo_selecionado, valor_selecionado, max_folhas, num_nibs_por_folha, cils_validos
                )
                
            if df_folhas is not None and not df_folhas.empty:
                st.success(f"‚úÖ {df_folhas['FOLHA'].max()} Folhas geradas com sucesso.")
                
                # Informar sobre as colunas exportadas
                colunas_exportadas = ['cil', 'prod', 'contador', 'leitura', 'mat_contador', 
                                    'med_fat', 'qtd', 'valor', 'situacao', 'acordo']
                st.info(f"üìã Cada folha CSV cont√©m as {len(colunas_exportadas)} primeiras colunas: {', '.join(colunas_exportadas)}")
                
                zip_data = generate_csv_zip(df_folhas, num_nibs_por_folha)
                
                if zip_data:
                    st.download_button(
                        label="üì¶ Baixar Arquivo ZIP com Folhas (CSV)",
                        data=zip_data,
                        file_name=f"Folhas_CSV_{tipo_selecionado}_{valor_selecionado or 'AVULSO'}_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.zip",
                        mime="application/zip"
                    )
                
                # Exibir informa√ß√µes espec√≠ficas para cada tipo
                if tipo_selecionado == "AVULSO":
                    # Exibir CILs n√£o encontrados (apenas para AVULSO)
                    if cils_nao_encontrados:
                        st.warning(f"‚ö†Ô∏è {len(cils_nao_encontrados)} CIL(s) n√£o foram encontrados (ou j√° estavam em 'prog'/n√£o-SUSP):")
                        st.code(", ".join(cils_nao_encontrados[:20]) + ("..." if len(cils_nao_encontrados) > 20 else ""))
                        
                    # Estat√≠sticas de sucesso (apenas para AVULSO)
                    if cils_validos:
                        cils_encontrados = len(cils_validos) - len(cils_nao_encontrados)
                        st.success(f"üìä **Resultado:** {cils_encontrados} de {len(cils_validos)} CIL(s) processados com sucesso.")
                else:
                    # Mensagem para PT e LOCALIDADE
                    st.success(f"üìä Folhas geradas para {tipo_selecionado}: {valor_selecionado}")
                    
            elif df_folhas is None:
                if tipo_selecionado == "AVULSO":
                    st.warning("‚ö†Ô∏è Nenhuma folha gerada. Verifique se os CILs existem no banco e t√™m crit√©rio 'SUSP'.")
                else:
                    st.warning("‚ö†Ô∏è Nenhuma folha gerada. Verifique se existem registros com crit√©rio 'SUSP' para o valor selecionado.")

# --- P√°ginas do Aplicativo ---
def login_page(db_manager):
    """P√°gina de login."""
    st.title("üîê Sistema de Gest√£o de Dados - Login")
    
    # Adicionar informa√ß√µes sobre usu√°rios padr√£o
    with st.expander("‚ÑπÔ∏è Informa√ß√µes de Acesso"):
        st.markdown("""
        **Usu√°rios Padr√£o:**
        - **Admin** / admin123 (Administrador)
        - **AssAdm** / adm123 (Assistente Administrativo)
        """)
    
    with st.form("login_form"):
        username = st.text_input("üë§ Nome de Usu√°rio")
        password = st.text_input("üîí Senha", type="password")
        submitted = st.form_submit_button("üöÄ Entrar")

        if submitted:
            if not username or not password:
                st.error("‚ùå Preencha todos os campos.")
            else:
                with st.spinner("Autenticando..."):
                    user_info = db_manager.autenticar_usuario(username, password)
                    if user_info:
                        st.session_state['authenticated'] = True
                        st.session_state['user'] = user_info
                        st.success("‚úÖ Login realizado com sucesso!")
                        st.rerun()
                    else:
                        st.error("‚ùå Nome de usu√°rio ou senha inv√°lidos.")

def manager_page(db_manager):
    """P√°gina principal ap√≥s o login."""
    
    if 'user' not in st.session_state:
        st.error("‚ùå Sess√£o inv√°lida. Fa√ßa login novamente.")
        st.session_state['authenticated'] = False
        st.rerun()
    
    user = st.session_state['user']
    
    # Sidebar melhorada
    with st.sidebar:
        st.markdown(f"### üëã Ol√°, {user['nome']}!")
        st.markdown(f"**Fun√ß√£o:** {user['role']}")
        
        if st.button("üö™ Sair", use_container_width=True):
            st.session_state['authenticated'] = False
            st.session_state['user'] = None
            st.rerun()
        
        st.markdown("---")
        
        # Altera√ß√£o de senha pessoal
        with st.expander("üîê Alterar Minha Senha"):
            with st.form("alterar_minha_senha"):
                nova_senha = st.text_input("Nova Senha", type="password")
                confirmar_senha = st.text_input("Confirmar Nova Senha", type="password")
                if st.form_submit_button("üîÑ Alterar Senha"):
                    if nova_senha and confirmar_senha:
                        if nova_senha == confirmar_senha:
                            sucesso, mensagem = db_manager.alterar_senha(user['id'], nova_senha)
                            if sucesso:
                                st.success("‚úÖ Senha alterada com sucesso!")
                            else:
                                st.error(f"‚ùå {mensagem}")
                        else:
                            st.error("‚ùå As senhas n√£o coincidem.")
                    else:
                        st.error("‚ùå Preencha todos os campos.")

    # Controle de acesso baseado em role
    if user['role'] == 'Administrador':
        st.title("üéØ Painel de Administra√ß√£o")
        tabs = st.tabs(["üì• Importa√ß√£o", "üìù Gera√ß√£o de Folhas", "üë• Gerenciamento de Usu√°rios", "üîÑ Reset de Estado"])
        
        with tabs[0]:
            # Importa√ß√£o
            st.markdown("### üì• Importa√ß√£o de Dados")
            st.warning("‚ö†Ô∏è Aten√ß√£o: A importa√ß√£o **substituir√°** todos os dados existentes na tabela BD, exceto os registros que j√° estavam com o estado 'prog'.")

            uploaded_file = st.file_uploader("Selecione o arquivo CSV:", type=["csv"], key="import_csv")

            if uploaded_file is not None:
                if st.button("üöÄ Processar e Importar para o Banco de Dados"):
                    with st.spinner("Processando e importando..."):
                        if db_manager.importar_csv(uploaded_file, 'BD'):
                            st.success("üéâ Importa√ß√£o conclu√≠da com sucesso!")
                            st.info("O banco de dados foi atualizado.")
                        else:
                            st.error("Falha na importa√ß√£o. Verifique o formato do arquivo.")
        
        with tabs[1]:
            # Gera√ß√£o de Folhas (compartilhada)
            gerar_folhas_trabalho(db_manager, user)
            
        with tabs[2]:
            # Gerenciamento de Usu√°rios
            gerenciar_usuarios(db_manager)
            
        with tabs[3]:
            # Reset de Estado
            reset_state_form(db_manager, "admin")
            
    else:  # Assistente Administrativo ou T√©cnico
        st.title("üìã Gera√ß√£o de Folhas de Trabalho")
        gerar_folhas_trabalho(db_manager, user)

# --- Fun√ß√£o Principal ---
def main():
    """Fun√ß√£o principal do aplicativo Streamlit."""
    st.set_page_config(
        page_title="V.Ferreira (Perdas)", 
        layout="wide",
        page_icon="üìä",
        initial_sidebar_state="expanded"
    )
    
    # Estilos CSS para melhor apar√™ncia
    st.markdown("""
    <style>
    .main .block-container {
        padding-top: 2rem;
    }
    .stButton button {
        width: 100%;
    }
    </style>
    """, unsafe_allow_html=True)
    
    # 1. Configura√ß√£o do DB
    try:
        db_manager = PostgresDatabaseManager(POSTGRES_URL)
    except Exception as e:
        st.error(f"‚ùå O aplicativo n√£o p√¥de se conectar ao banco de dados: {e}")
        st.info("""
        **Solu√ß√£o de problemas:**
        1. Verifique se as credenciais est√£o corretas nos secrets do Streamlit
        2. Confirme se o banco PostgreSQL est√° acess√≠vel
        3. Verifique a conex√£o de rede
        """)
        return

    # 2. Inicializa√ß√£o do Estado de Sess√£o
    if 'authenticated' not in st.session_state:
        st.session_state['authenticated'] = False
        st.session_state['user'] = None

    # 3. Roteamento
    if st.session_state['authenticated']:
        manager_page(db_manager)
    else:
        login_page(db_manager)

if __name__ == '__main__':
    main()